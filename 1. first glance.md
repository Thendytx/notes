1. object based & object oriented

    基于对象， 只表明有对象概念<br>
    面向对象， 则存在类之间的复杂关系， 如继承
2. class without pointer & class with pointer

    类， 可以分为两类： 包含指针的类， 不包含指针的类<br>
    经典的包含指针的类：string<br>
    经典的不包含指针的类：complex(在后面要自己实现)<br>
3. 头文件
    1. 防御式声明： 头文件的一般格式

        下述代码展示了头文件内一般应具备的基本格式。<br>这种声明方式使用了条件编译语句， 被称为防御性声明。 其作用是， 当多个源文件中需要使用本头文件的内容时， 无需考虑头文件的先后关系与是否包含本头文件， 只要在可能需要的地方放心使用#include就可以了。
        <br>效果为， 编译的预处理阶段， 检查是否已定义了__MACRO__宏， 若已定义， 则不会将if之间的内容再次包含。 这样， 只有第一次被检查到的时候， if之间的代码被包含进来。

            #ifndef __MACRO__
            #define __MACRO__
            
            ...

            #endif
    2. if之间

        1. 前置声明 forward declarations
            
            这个部分可能包括的有： 会用到的头文件的包含， 全局变量/对象的声明， 类名， 方法的声明

                #include<cmath>

                class ostream;
                class complex;

                complex&
                  __doap1  (complex* ths, const complex& r);
        2. 类的声明 class declarations

            这个部分就是类的声明。 类的名字， 它的数据成员， 它的成员函数的声明（或定义）。

                class complex
                {
                    ...
                };
        3. 类的定义 class definition

            这里可能有类的static数据成员的初始化， 更多的是类的声明中没有直接定义的函数的定义。

                complex::function1(){
                    ...
                }
3. class complex的声明

        class complex // class head
                      // following is called class body
        {
            public:
                complex (double r = 0, double i = 0) : re (r), im (i)
                {

                }
                complex& operator += (const complex&);
                double real () const { return re;}
                double imag () const { return im;}
            private:
                double re, im;

                friend complex& __doap1 (complex*, const conplex&);
        };

        // in main
        {
            complex c1(2.5, 1.5);
            complex c1(2, 1);
        }
4. class template简介

    如果有的复数， 实部虚部是float类型， 怎么办？ 如果是int类型呢？<br>
    为了避免仅仅为了不同的数据类型， 而写出多个基本完全重复的类， cpp提供了模板。

        // 这里的T除了关键字，随便是什么都可以。 只要合法。
        template<typename T>
        class complex
        {
            public:
                complex (T r = 0, T i = 0) : re (r), im (i)
                {

                }
                complex& operator += (const complex&);
                T real () const { return re;}
                T imag () const { return im;}
            private:
                T re, im;

                friend complex& __doap1 (complex*, const conplex&);
        };

        // in main
        {
            // <type>的作用是将具体类型type绑定至T
            complex<double> c1(2.5, 1.5);
            complex<int> c1(2, 1);
        }
