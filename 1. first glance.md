1. object based & object oriented

    基于对象， 只表明有对象概念<br>
    面向对象， 则存在类之间的复杂关系， 如继承
2. class without pointer & class with pointer

    类， 可以分为两类： 包含指针的类， 不包含指针的类<br>
    经典的包含指针的类：string<br>
    经典的不包含指针的类：complex(在后面要自己实现)<br>
3. 头文件
    1. 防御式声明： 头文件的一般格式

        下述代码展示了头文件内一般应具备的基本格式。<br>这种声明方式使用了条件编译语句， 被称为防御性声明。 其作用是， 当多个源文件中需要使用本头文件的内容时， 无需考虑头文件的先后关系与是否包含本头文件， 只要在可能需要的地方放心使用#include就可以了。
        <br>效果为， 编译的预处理阶段， 检查是否已定义了__MACRO__宏， 若已定义， 则不会将if之间的内容再次包含。 这样， 只有第一次被检查到的时候， if之间的代码被包含进来。

            #ifndef __MACRO__
            #define __MACRO__
            
            ...

            #endif
    2. if之间

        1. 前置声明 forward declarations
            
            这个部分可能包括的有： 会用到的头文件的包含， 全局变量/对象的声明， 类名， 方法的声明

                #include<cmath>

                class ostream;
                class complex;

                complex&
                  __doap1  (complex* ths, const complex& r);
        2. 类的声明 class declarations

            这个部分就是类的声明。 类的名字， 它的数据成员， 它的成员函数的声明（或定义）。

                class complex
                {
                    ...
                };
        3. 类的定义 class definition

            这里可能有类的static数据成员的初始化， 更多的是类的声明中没有直接定义的函数的定义。

                complex::function1(){
                    ...
                }
3. class complex的声明

        class complex // class head
                      // following is called class body
        {
            public:
                complex (double r = 0, double i = 0) : re (r), im (i) { }
                complex& operator += (const complex&);
                double real () const { return re;}
                double imag () const { return im;}
            private:
                double re, im;

                friend complex& __doap1 (complex*, const conplex&);
        };

        // in main function or whatever
        {
            complex c1(2.5, 1.5);
            complex c1(2, 1);
        }
4. class template : intro

    如果有的复数， 实部虚部是float类型， 怎么办？ 如果是int类型呢？<br>
    为了避免仅仅为了不同的数据类型， 而写出多个基本完全重复的类， cpp提供了模板。

        // 这里的T除了关键字，随便是什么都可以。 只要合法。
        template<typename T>
        class complex
        {
            public:
                complex (T r = 0, T i = 0) : re (r), im (i) { }
                complex& operator += (const complex&);
                T real () const { return re;}
                T imag () const { return im;}
            private:
                T re, im;

                friend complex& __doap1 (complex*, const conplex&);
        };

        // in main
        {
            // <type>的作用是将具体类型type绑定至T
            complex<double> c1(2.5, 1.5);
            complex<int> c1(2, 1);
        }
5. inline function

    函数在类体内定义， 则函数是一个inline function。 或者， 函数使用了inline关键字进行修饰， 则函数是一个inline函数。<br>内联函数类似宏。 优点是， 运行速度快。 缺点也类似， 会使代码变长。 但是， 函数有类型检查， 这使得inline函数比宏更加安全。<br>inline关键字的使用或将函数定义在类体内只是对编译器的一种建议， 是否实现为inline函数由编译器行为决定。 一般而言简单的函数可以被实现为inline函数， 而复杂的函数则不会被实现位inline函数。<br>
6. access level 访问级别

    访问级别： public、private、protected<br>
    一般而言， 数据是private的， 而方法可以是public的， 也可以是private的。<br>
    public与private可以任意地交错， 而不必一定将class body分为两部分/三部分（如果class body过长， 这样做可能具备一定的合理性）
7. constructor 构造函数

        complex c1(2,1);                // 创建了对象c1， 实部为2， 虚部为1
        complex c2;                     // 创建了对象c2， 实部为0， 虚部为0
        complex* p = new complex(4);    // 创建了一个对象， 实部为4， 虚部为0
    cpp语法要求， 构造函数的函数名与类名相同。 并且， 构造函数没有返回值类型。 或者说， 构造函数的返回值类型就是他所属的类。<br>
    构造函数可以有参数， 且实参参数可以有默认值。 // 当然， 其他函数的实参也可以有默认值
    1. initialization list

        这是构造函数特有的语法。 初始化列表。 “: 成员1 (init_value), 成员2 (init_value), …”<br>
        对于一个变量而言， 其有效值可以通过两种过程获得： 初始化initialization， 赋值assignment。 初始化列表就是在初始化阶段给变量值的方法， 其余的方法都属于赋值。 初始化的效率更高， 应当使用初始化列表， 而不是构造函数中的赋值。<br>
    cpp中， 不存在直接调用构造函数的方法； 对于构造函数的调用， 只有创建对象这种办法。
    2. overloading 重载

        构造函数可以重载且经常重载。<br>cpp的重载是指， 同一个作用域中， 可以存在多个函数名相同的不同函数。 重载的原理是， 编译器根据函数名、参数列表等进行编码后， 可重载的函数的实际名称会有所不同。<br>

            class complex // class head
                        // following is called class body
            {
                public:
                    complex (double r = 0, double i = 0) : re (r), im (i) { }
                    // complex () : re (0), im (0) { }
                    complex& operator += (const complex&);
                    double real () const { return re;}
                    void real(double r) { re = r };
                    double imag () const { return im;}
                private:
                    double re, im;

                    friend complex& __doap1 (complex*, const conplex&);
            };
        1. 参数列表不相同
            
            函数重载时， 函数名相同， 参数列表不能相同。 即， 对于同名函数， 其形参的个数、 类型、 类型的顺序不能完全相同。<br>
        2. 二义性
            
            上面代码中， 注释掉的构造函数虽然与未注释的构造函数在参数列表上不同， 但由于如果二者同时存在， 那么在无参数地创建对象时， 既可以解释为调用了无参构造函数， 也可以解释为以默认参数调用了有有参构造函数。 这样的二义性使得这两个函数不能重载。